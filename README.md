# Amazon_sales_project
## PROJECT OVERVIEW
I have worked on analyzing a dataset of over 1400 sales records from an Amazon-like e-commerce platform. This project involves extensive querying of customer behavior, product performance, and sales trends using PostgreSQL. Through this project, I have tackled various SQL problems, including revenue analysis, customer segmentation, and inventory management.
The project also focuses on data cleaning, handling null values, and solving real-world business problems using structured queries.
An ERD diagram is included to visually represent the database schema and relationships between tables.
## DATABASE SETUP AND DESIGN
### Schema structure
```sql -- AMAZON PROJECT-ADVANCED SQL
-- CATEGORY TABLE

-- CATEGORY TABLE
CREATE TABLE category
(
category_id INT PRIMARY KEY,
category_name VARCHAR(20)
);

-- CUSTOMERS TABLE
CREATE TABLE customers
(
customer_id INT PRIMARY KEY,
first_name VARCHAR(20),
last_name VARCHAR(20),
state VARCHAR(20),
address VARCHAR(30) DEFAULT ('XXXX')
);

-- SELLERS TABLE
CREATE TABLE sellers
(
seller_id INT PRIMARY KEY,
seller_name VARCHAR(30),
origin VARCHAR(30)
);

-- PRODUCTS TABLE 
drop table if exists products;
CREATE TABLE products
(
product_id INT PRIMARY KEY,
product_name VARCHAR(20),
price FLOAT,
cogs FLOAT,
category_id INT,-- fk
constraint product_fk_category FOREIGN KEY (category_id) references category(category_id)
);

-- ORDERS TABLE
CREATE TABLE if not exists orders
(
order_id INT PRIMARY KEY,
order_date DATE,
customer_id INT, --FK
seller_id INT, --FK
order_status VARCHAR(25),
constraint orders_fk_customers foreign key(customer_id) references customers(customer_id),
constraint orders_fk_sellers foreign key(seller_id) references sellers(seller_id)
);

-- order_items table
drop table if exists order_items;
CREATE TABLE if not exists order_items
(
order_item_id INT PRIMARY KEY,
order_id INT, -- FK
product_id INT, --FK
quantity INT,
price_per_unit FLOAT,
constraint order_itmes_fk_orders foreign key(order_id) references orders(order_id),
constraint order_itmes_fk_products foreign key(product_id) references products(product_id)
);

-- PAYMENT TABLE
CREATE TABLE payments
(
payment_id INT PRIMARY KEY,
order_id INT, --FK
payment_date DATE,
payment_status VARCHAR(30),
constraint payments_fk_orders foreign key(order_id) references orders(order_id)
);

-- shipping table
CREATE TABLE shippings
(
shipping_id INT PRIMARY KEY,
order_id INT, --FK
shipping_date DATE, 
return_date DATE,
shipping_providers VARCHAR(20),
delivery_status VARCHAR(20),
constraint shippings_fk_orders foreign key(order_id) references orders(order_id)
);

-- INVENTORY TABLE
CREATE TABLE inventory
(
inventory_id INT PRIMARY KEY,
product_id INT, --FK
stock INT,
warehouse_id INT, 
last_stock_date DATE,
constraint inventory_fk_products foreign key(product_id) references products(product_id)
);
```
## Objective
The primary objective of this project is to showcase SQL proficiency through complex queries that address real-world e-commerce business challenges. The analysis covers various aspects of e-commerce operations, including:
1. Customer behavior
2. Sales trends
3. Inventory management
4. Payment and shipping analysis
5. Forecasting and product performance
6. Identifying Business Problems
## Key business problems identified:
1. Low product availability due to inconsistent restocking.
2. High return rates for specific product categories.
3. Significant delays in shipments and inconsistencies in delivery times.
4. High customer acquisition costs with a low customer retention rate.
# Solving Business Problems

## Solutions Implemented:

### 1. Top Selling Products 
  Query the top 10 products by total sales value.
  Challenge: Include product name, total quantity sold, and total sales value.
  ```sql SELECT
    p.product_id,
    p.product_name,
    SUM(oi.quantity) AS total_quantity_sold,
    SUM(oi.quantity * oi.price_per_unit) AS total_sales_value
FROM
    order_items oi
JOIN
    products p ON oi.product_id = p.product_id
GROUP BY
    p.product_id, p.product_name
ORDER BY
    total_sales_value DESC
LIMIT 10;
----------------------------------------------------------------------------------------
```
### 2. Revenue by Category  
Calculate total revenue generated by each product category.  
Challenge: Include the percentage contribution of each category to total revenue.  
```sql WITH category_revenue AS (
    SELECT
        c.category_id,
        c.category_name,
        SUM(oi.quantity * oi.price_per_unit) AS category_sales
    FROM
        order_items oi
    JOIN
        products p ON oi.product_id = p.product_id
    JOIN
        category c ON p.category_id = c.category_id
    GROUP BY
        c.category_id, c.category_name
),
total_revenue AS (
    SELECT SUM(oi.quantity * oi.price_per_unit) AS total
    FROM order_items oi
)
SELECT
    cr.category_id,
    cr.category_name,
    cr.category_sales AS total_revenue_by_category,
    (cr.category_sales / tr.total) * 100 AS percentage_contribution
FROM
    category_revenue cr
CROSS JOIN
    total_revenue tr
ORDER BY
    total_revenue_by_category DESC;
```
-- ----------------------------------------------------------------------------------------
### 3. Average Order Value (AOV)  
Compute the average order value for each customer.  
Challenge: Include only customers with more than 5 orders.  
```sql
WITH customer_orders AS (
    SELECT
        c.customer_id,
        CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
        COUNT(DISTINCT o.order_id) AS order_count,
        SUM(oi.quantity * oi.price_per_unit) AS total_spend
    FROM
        customers c
    JOIN
        orders o ON c.customer_id = o.customer_id
    JOIN
        order_items oi ON o.order_id = oi.order_id
    GROUP BY
        c.customer_id, c.first_name, c.last_name
    HAVING
        COUNT(DISTINCT o.order_id) > 5
)
SELECT
    customer_id,
    customer_name,
    order_count,
    total_spend,
    total_spend / order_count AS average_order_value
FROM
    customer_orders
ORDER BY
    average_order_value DESC;
```
-- ---------------------------------------------------------------------------------------
### 4. Monthly Sales Trend  
Query monthly total sales over the past year.  
Challenge: Display the sales trend, grouping by month, return current_month sale, last month sale!  
```sql
SELECT
    year,
    month,
    total_sale AS current_month_sale,
    LAG(total_sale, 1) OVER(ORDER BY year, month) AS last_month_sale
FROM (
    SELECT
        EXTRACT(MONTH FROM o.order_date) AS month,
        EXTRACT(YEAR FROM o.order_date) AS year,
        SUM(oi.quantity * oi.price_per_unit) AS total_sale
    FROM
        orders o
    JOIN
        order_items oi ON oi.order_id = o.order_id
    WHERE
        o.order_date >= CURRENT_DATE - INTERVAL '1 year'
    GROUP BY
        month,year
    ORDER BY
        year, month
) AS monthly_sales;
```
-- ---------------------------------------------------------------------------------------
### 5. Customers with No Purchases  
Find customers who have registered but never placed an order.  
Challenge: List customer details and the time since their registration.  
```sql
-- using not in
SELECT *
FROM customers
WHERE customer_id NOT IN (SELECT
    DISTINCT customer_id
    FROM orders
    );
-- using left join
SELECT *
FROM customers as c
LEFT JOIN
orders as o
ON o.customer_id = c.customer_id
WHERE o.customer_id IS NULL;
```
-- ----------------------------------------------------------------------------------------- 
### 6. Best-Selling Categories by State  
Identify the best-selling product category for each state.  
Challenge: Include the total sales for that category within each state.  
```sql
WITH state_category_sales AS (
    SELECT
        c.state,
        cat.category_name,
        SUM(oi.quantity * oi.price_per_unit) AS total_sales,
        RANK() OVER(PARTITION BY c.state ORDER BY SUM(oi.quantity * oi.price_per_unit) DESC) AS sales_rank
    FROM
        orders o
    JOIN
        customers c ON o.customer_id = c.customer_id
    JOIN
        order_items oi ON o.order_id = oi.order_id
    JOIN
        products p ON oi.product_id = p.product_id
    JOIN
        category cat ON p.category_id = cat.category_id
    GROUP BY
        c.state, cat.category_name
)
SELECT
    state,
    category_name AS best_selling_category,
    total_sales AS category_sales
FROM
    state_category_sales
WHERE
    sales_rank = 1
ORDER BY
    state;
```
-- ----------------------------------------------------------------------------------------
### 7. Customer Lifetime Value (CLTV)  
Calculate the total value of orders placed by each customer over their lifetime.  
Challenge: Rank customers based on their CLTV.  
*/  
```sql
SELECT  
    c.customer_id,  
    CONCAT(c.first_name, ' ', c.last_name) as full_name,  
    SUM(oi.quantity * oi.price_per_unit) as CLTV,  
    DENSE_RANK() OVER(ORDER BY SUM(oi.quantity * oi.price_per_unit) DESC) as customer_rank  
FROM orders as o  
JOIN customers as c ON c.customer_id = o.customer_id  
JOIN order_items as oi ON oi.order_id = o.order_id  
GROUP BY c.customer_id, c.first_name, c.last_name  
ORDER BY customer_rank;
```
-- ---------------------------------------------------------------------------------------
### 8. Inventory Stock Alerts
Query: products with stock levels below a certain threshold (e.g., less than 10 units).

Challenge: Include last restock date and warehouse information.
```sql
SELECT
    i.inventory_id,
    p.product_name,
    i.stock as current_stock_left,
    i.last_stock_date,
    i.warehouse_id

FROM inventory as i
join
products as p
ON p.product_id = i.product_id
WHERE stock < 10
```
-- ---------------------------------------------------------------------------------------
### 9. Shipping Delays  
Identify orders where the shipping date is later than 7 days after the order date.  
Challenge: Include customer, order details, and delivery provider.  
```sql
SELECT
    c.customer_id,
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    o.order_id,
    o.order_date,
    s.shipping_date,
    s.shipping_providers AS delivery_provider,
    s.shipping_date - o.order_date AS days_to_ship,
    s.delivery_status
FROM
    orders o
JOIN
    customers c ON o.customer_id = c.customer_id
JOIN
    shippings s ON o.order_id = s.order_id
WHERE
    s.shipping_date > o.order_date + INTERVAL '7 days'
ORDER BY
    days_to_ship DESC;
```
-- --------------------------------------------------------------------------------------
### 10. Payment Success Rate  
Calculate the percentage of successful payments across all orders.  
Challenge: Include breakdowns by payment status (e.g., failed, pending).  
```sql
SELECT
    p.payment_status,
    COUNT(*) AS transaction_count,
    COUNT(*) * 100.0 / (SELECT COUNT(*) FROM payments) AS percentage
FROM
    orders o
JOIN
    payments p ON o.order_id = p.order_id
GROUP BY
    p.payment_status
ORDER BY
    transaction_count DESC;
```
-- ---------------------------------------------------------------------------------------
### 11. Top Performing Sellers  
Find the top 5 sellers based on total sales value.  
Challenge: Include both successful and failed orders, and display their percentage of successful orders.  
```sql
WITH seller_performance AS (
    SELECT
        s.seller_id,
        s.seller_name,
        COUNT(DISTINCT o.order_id) AS total_orders,
        SUM(CASE WHEN o.order_status = 'Completed' THEN 1 ELSE 0 END) AS successful_orders,
		SUM(CASE WHEN o.order_status = 'Cancelled' THEN 1 ELSE 0 END) AS cancelled_orders,
        SUM(oi.quantity * oi.price_per_unit) AS total_sales_value
    FROM
        orders o
    JOIN
        sellers s ON o.seller_id = s.seller_id
    JOIN
        order_items oi ON o.order_id = oi.order_id
    GROUP BY
        s.seller_id, s.seller_name
)
SELECT
    seller_id,
    seller_name,
    total_sales_value,
    total_orders,
    successful_orders,
	cancelled_orders,
    (successful_orders * 100.0 / total_orders) AS success_rate_percentage
FROM
    seller_performance
ORDER BY
    total_sales_value DESC
LIMIT 5;
```
-- --------------------------------------------------------------------------------------
### 12. Product Profit Margin  
Calculate the profit margin for each product.  
Challenge: Rank products by their profit margin (highest to lowest).  
```sql
SELECT
    product_id,
    product_name,
    profit_margin,
    DENSE_RANK() OVER(ORDER BY profit_margin DESC) AS product_ranking
FROM (
    SELECT
        p.product_id,
        p.product_name,
        (SUM(oi.quantity * oi.price_per_unit) - SUM(p.cogs * oi.quantity)) / 
        SUM(oi.quantity * oi.price_per_unit) * 100 AS profit_margin
    FROM
        order_items oi
    JOIN
        products p ON oi.product_id = p.product_id
    GROUP BY
        p.product_id, p.product_name
) AS profit_calculation
ORDER BY
    product_ranking;
```
-- -------------------------------------------------------------------------------------
### 13. Most Returned Products  
Query the top 10 products by the number of returns.  
Challenge: Display the return rate as a percentage of total units sold for each product.  
```sql
SELECT
    p.product_id,
    p.product_name,
    COUNT(*) AS total_units_sold,
    SUM(CASE WHEN o.order_status = 'Returned' THEN 1 ELSE 0 END) AS total_returns,
    SUM(CASE WHEN o.order_status = 'Returned' THEN 1 ELSE 0 END) * 100.0 / COUNT(*) AS return_rate_percentage
FROM
    order_items oi
JOIN
    products p ON oi.product_id = p.product_id
JOIN
    orders o ON oi.order_id = o.order_id
GROUP BY
    p.product_id, p.product_name
ORDER BY
    total_returns DESC
LIMIT 10;
```
-- ------------------------------------------------------------------------------------------
### 14. Inactive Sellers  
Identify sellers who haven't made any sales in the last 6 months.  
Challenge: Show the last sale date and total sales from those sellers.  
```sql
WITH inactive_sellers AS (
    SELECT *
	FROM sellers
		WHERE seller_id NOT IN 
		(SELECT seller_id FROM orders WHERE order_date >= CURRENT_DATE - INTERVAL '6 month')
)
SELECT
    s.seller_id,
    s.seller_name,
    MAX(o.order_date) AS last_sale_date,
    COUNT(o.order_id) AS total_orders,
    SUM(oi.quantity * oi.price_per_unit) AS total_sales_value
FROM
    sellers s
JOIN
    orders o ON s.seller_id = o.seller_id
JOIN
    order_items oi ON o.order_id = oi.order_id
WHERE
    s.seller_id IN (SELECT seller_id FROM inactive_sellers)
GROUP BY
    s.seller_id, s.seller_name
ORDER BY
    last_sale_date;
```
-- ----------------------------------------------------------------------------------
### 15. IDENTITY customers into returning or new  
if the customer has done more than 2 returns categorize them as returning otherwise new  
Challenge: List customers id, name, total orders, total returns  
```sql
SELECT
    c.customer_id,
    CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
    COUNT(DISTINCT o.order_id) AS total_orders,
    SUM(CASE WHEN o.order_status = 'Returned' THEN 1 ELSE 0 END) AS total_returns,
    CASE
        WHEN SUM(CASE WHEN o.order_status = 'Returned' THEN 1 ELSE 0 END) > 2 
        THEN 'Returning'
        ELSE 'New'
    END AS customer_type
FROM
    customers c
JOIN
    orders o ON c.customer_id = o.customer_id
GROUP BY
    c.customer_id, c.first_name, c.last_name
ORDER BY
    total_returns DESC;
```
-- ---------------------------------------------------------------------------------------
### 16. Top 5 Customers by Orders in Each State  
Identify the top 5 customers with the highest number of orders for each state.  
Challenge: Include the number of orders and total sales for each customer.  
```sql
WITH ranked_customers AS (
    SELECT
        c.state,
        c.customer_id,
        CONCAT(c.first_name, ' ', c.last_name) AS customer_name,
        COUNT(DISTINCT o.order_id) AS order_count,
        SUM(oi.quantity * oi.price_per_unit) AS total_spend,
        RANK() OVER(PARTITION BY c.state ORDER BY COUNT(DISTINCT o.order_id) DESC) AS state_rank
    FROM
        customers c
    JOIN
        orders o ON c.customer_id = o.customer_id
    JOIN
        order_items oi ON o.order_id = oi.order_id
    GROUP BY
        c.state, c.customer_id, c.first_name, c.last_name
)
SELECT
    state,
    customer_id,
    customer_name,
    order_count,
    ROUND(total_spend::numeric, 2) AS total_sales
FROM
    ranked_customers
WHERE
    state_rank <= 5
ORDER BY
    state, state_rank;
```
-- -----------------------------------------------------------------------------------------
### 17. Revenue by Shipping Provider  
Calculate the total revenue handled by each shipping provider.  
Challenge: Include the total number of orders handled and the average delivery time for each provider.  
 ```sql
SELECT
    s.shipping_providers AS provider_name,
    COUNT(DISTINCT o.order_id) AS total_orders,
    ROUND(SUM(oi.quantity * oi.price_per_unit)::numeric, 2) AS total_revenue,
    AVG(s.shipping_date - o.order_date) AS avg_delivery_days
FROM
    orders o
JOIN
    order_items oi ON o.order_id = oi.order_id
JOIN
    shippings s ON o.order_id = s.order_id
GROUP BY
    s.shipping_providers
ORDER BY
    total_revenue DESC;
```
-- ----------------------------------------------------------------------------------
### 18. Top 10 product with highest decreasing revenue ratio compare to last year(2022) and current_year (2023)
Challenge: Return product_id, product_name, category_name, 2022 revenue and 2023 revenue decrease ratio at end Round the result
Note: Decrease ratio = (cr-ls)/ls*100 (cs = current_year ls=last_year)
```sql
WITH last_year_sale AS (
    select
        p.product_id,
        p.product_name,
        c.category_name,
        SUM(oi.quantity*oi.price_per_unit) AS revenue
    FROM orders AS o
    JOIN order_items AS oi ON oi.order_id = o.order_id
    JOIN products AS p ON p.product_id = oi.product_id
    JOIN category AS c ON p.category_id = c.category_id
    WHERE EXTRACT(YEAR FROM o.order_date) = 2022
    GROUP BY p.product_id, p.product_name, c.category_name
),
current_year_sale AS (
    select
        p.product_id,
        SUM(oi.quantity*oi.price_per_unit) AS revenue
    FROM orders AS o
    JOIN order_items AS oi ON oi.order_id = o.order_id
    JOIN products AS p ON p.product_id = oi.product_id
    WHERE EXTRACT(YEAR FROM o.order_date) = 2023
    group by p.product_id
)
SELECT
    ls.product_id,
    ls.product_name,
    ls.category_name,
    ROUND(ls.revenue :: numeric, 2) AS "2022Revenue",
    ROUND(cs.revenue ::numeric, 2) AS "2023Revenue",
    ROUND((cs.revenue - ls.revenue)::numeric / NULLIF(ls.revenue, 0) ::numeric * 100, 2) AS decrease_ratio
FROM last_year_sale AS ls
JOIN current_year_sale AS cs ON ls.product_id = cs.product_id
WHERE ls.revenue > 0 AND cs.revenue < ls.revenue
ORDER BY decrease_ratio ASC
LIMIT 10;
-- -----------------------------------------------------------------------------------------
```
## Final Task

### -- Store Procedure
create a function as soon as the product is sold the the same quantity should reduced from inventory table
after adding any sales records it should update the stock in the inventory table based on the product and qty purchased
```sql
CREATE OR REPLACE PROCEDURE add_sales(
    p_order_id INT,
    p_customer_id INT,
    p_seller_id INT,
    p_order_item_id INT,
    p_product_id INT,
    p_quantity INT
)
LANGUAGE plpgsql
AS $$
DECLARE
    v_count INT;
    v_price FLOAT;
    v_product VARCHAR(50);
    v_current_stock INT;
BEGIN
    -- Get product details
    SELECT price, product_name
    INTO v_price, v_product
    FROM products
    WHERE product_id = p_product_id;
    
    -- Verify product exists
    IF NOT FOUND THEN
        RAISE NOTICE 'Product ID % does not exist', p_product_id;
        RETURN;
    END IF;
    
    -- Check inventory availability
    SELECT MAX(stock), COUNT(*)
    INTO v_current_stock, v_count
    FROM inventory
    WHERE product_id = p_product_id
    AND stock >= p_quantity
	group by product_id;
    
    -- Process order if stock available
    IF v_count > 0 THEN
        BEGIN
			SELECT COALESCE(MAX(order_id), 0) + 1 INTO p_order_id FROM orders;
		    SELECT COALESCE(MAX(order_item_id), 0) + 1 INTO p_order_item_id FROM order_items;
            -- Create order record
            INSERT INTO orders(order_id, order_date, customer_id, seller_id)
            VALUES (p_order_id, CURRENT_DATE, p_customer_id, p_seller_id);
            
            -- Add order item
            INSERT INTO order_items(
                order_item_id, 
                order_id, 
                product_id, 
                quantity, 
                price_per_unit
            )
            VALUES (
                p_order_item_id, 
                p_order_id, 
                p_product_id, 
                p_quantity, 
                v_price
            );
            
            -- Update inventory
            UPDATE inventory
            SET stock = stock - p_quantity
            WHERE product_id = p_product_id;
            
            RAISE NOTICE 'Success: Ordered % units of % (Product ID: %). Remaining stock: %', 
                p_quantity, 
                v_product, 
                p_product_id, 
                (v_current_stock - p_quantity);
        EXCEPTION
            WHEN OTHERS THEN
                RAISE EXCEPTION 'Order processing failed: %', SQLERRM;
        END;
    ELSE
        RAISE NOTICE 'Insufficient stock: Only % units available for % (Product ID: %)', 
            COALESCE(v_current_stock, 0), 
            v_product, 
            p_product_id;
    END IF;
END;
$$;
```
#### testing store procedure
```sql
call add_sales(1006,2,6,1008,1,6);
```
# Learning Outcomes

This project enabled me to:

- Design and implement a normalized database schema.
- Clean and preprocess real-world datasets for analysis.
- Use advanced SQL techniques, including window functions, subqueries, and joins.
- Conduct in-depth business analysis using SQL.
- Optimize query performance and handle large datasets efficiently.

# Conclusion

This advanced SQL project successfully demonstrates my ability to solve real-world e-commerce problems using structured queries. From improving customer retention to optimizing inventory and logistics, the project provides valuable insights into operational challenges and solutions.

By completing this project, I have gained a deeper understanding of how SQL can be used to tackle complex data problems and drive business decision-making.
![image](https://github.com/user-attachments/assets/ca5ab07e-2c3f-4b0c-983a-27329f9941d3)

![image](https://github.com/user-attachments/assets/4d4d3783-be6b-4098-a9dd-012d3e95b9b5)

